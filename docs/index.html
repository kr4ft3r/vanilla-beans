<!DOCTYPE html>
<html>
        <head>
                <link rel="stylesheet" type="text/css" href="vanilla-beans.css">
                <script src="vanilla-beans.min.js"></script>
                <script type="text/javascript">
                        const demoData = {
                                spriteDefinitions: {},
                                sprites: [],
                                spritesData: new HashTable(), // Stuff otherwise encapsulated by game object
                                containerElem: null,
                                collisionGrid: null,
                                sequence: null,
                                currentSequenceMemberStart: 0.0,
                                nextSequenceMemberDelay: 0.0,
                                cloudMatrix: [],
                        };
                        
                        function domReady(fn) {
                                // If we're early to the party
                                document.addEventListener("DOMContentLoaded", fn);
                                // If late; I mean on time.
                                if (document.readyState === "interactive" || document.readyState === "complete" ) {
                                        fn();
                                }
                        }

                        domReady(() => domLoaded());

                        function domLoaded() {
                                console.log("hello");
                                demoData.spriteDefinitions['heart'] = new SpriteDefinition('test', './heart.png', 64, 64);
                                demoData.spriteDefinitions['cloudpuff'] = new SpriteDefinition(
                                        'test2', './cloudpuff.png', 64, 64, {width: 4, height: 1});
                                const containerElem = document.getElementById('test-container');
                                demoData.containerElem = containerElem;
                                demoData.collisionGrid = new FixedResolutionGrid(
                                        128, 8, 6,
                                        (s, p) => { const b = s.getBoundingBox();
                                                return b.x1 <= p.x && b.y1 <= p.y &&
                                                b.x2 >= p.x && b.y2 >= p.y;},
                                        (s1, s2) => { const b1 = s1.getBoundingBox(); const b2 = s2.getBoundingBox();
                                                return Collision.simpleBoxesOverlap(b1, b2);
                                        }
                                );

                                demoData.sequence = new Queue();
                                const spawnHeartAction = () => {
                                        createSprite('heart', new Vector2(0, 100));
                                        demoData.nextSequenceMemberDelay = 0.5;
                                }
                                demoData.sequence.enqueue(spawnHeartAction);
                                demoData.sequence.enqueue(spawnHeartAction);
                                demoData.sequence.enqueue(spawnHeartAction);
                                
                                containerElem.addEventListener("click", spriteContainerClicked);
                                
                                Noise.seed(Math.random());
                                for (var x = 0; x < 105; x++) {
                                        for (var y = 0; y < 30; y++) {
                                                let value = Noise.simplex2(x /1, y / 1);
                                                if (value > 0.7) demoData.cloudMatrix.push({x:x*10, y:y*10}); //createSprite("cloudpuff", {x:x*10, y:y*10+100});
                                        }
                                }
                                const puffAnimLength = 0.1;
                                for (let i = 0; i < demoData.cloudMatrix.length; i++)
                                        createSprite("cloudpuff", new Vector2(
                                                demoData.cloudMatrix[i].x+1024, 
                                                demoData.cloudMatrix[i].y+50),
                                                new TimedSequence(
                                                        [
                                                                {
                                                                        duration: puffAnimLength,
                                                                        action: (sprite) => {
                                                                                sprite.sheetPosition.x = 1;
                                                                        }
                                                                },
                                                                {
                                                                        duration: puffAnimLength,
                                                                        action: (sprite) => {
                                                                                sprite.sheetPosition.x = 2;
                                                                        }
                                                                },
                                                                {
                                                                        duration: puffAnimLength,
                                                                        action: (sprite) => {
                                                                                sprite.sheetPosition.x = 3;
                                                                        }
                                                                },
                                                                {
                                                                        duration: puffAnimLength,
                                                                        action: (sprite) => {
                                                                                sprite.domElement.style.display = "none";
                                                                        }
                                                                },
                                                        ]));
                                
                                window.requestAnimationFrame(frame);
                                
                        }
                        
                        function createSprite(name, position, animation = null) {
                                const spriteDef = demoData.spriteDefinitions[name];
                                let sprite = new Sprite(
                                        name+demoData.sprites.length, 
                                        spriteDef, 
                                        {position: position, scale: {x:1.0,y:1.0}}
                                );
                                Sprite.addToContainer(demoData.containerElem, sprite);
                                
                                if (animation !== null && animation.target === null)
                                        animation.target = sprite;
                                demoData.sprites.push(sprite);
                                demoData.spritesData.set(sprite.id, 
                                        {directionX:1, timeAlive:0.0, animation: animation, tag: name});
                                demoData.collisionGrid.insert(sprite, sprite.getBoundingBox());
                        }
                        
                        function destroySprite(sprite) {
                                Sprite.removeFromContainer(sprite);
                                demoData.collisionGrid.remove(sprite, sprite.getBoundingBox());
                                //demoData.spritesData.remove(sprite.id);
                        }
                        
                        function spriteContainerClicked(event) {
                                const rect = event.currentTarget.getBoundingClientRect();
                                const point = {
                                        x: event.clientX - rect.left,
                                        y: event.clientY - rect.top
                                }
                                //console.log(point);
                                const hits = demoData.collisionGrid.getAtPoint(point);
                                console.log(hits);
                                if (hits.length > 0) {
                                        const sprite = hits[0];
                                        if (demoData.spritesData.get(sprite.id).tag === "cloudpuff") {
                                                demoData.spritesData.get(sprite.id).
                                                        animation.start();
                                                demoData.collisionGrid.remove(
                                                        sprite, sprite.getBoundingBox());
                                        }
                                        
                                }
                        }
                        
                        var previousFrameTimestamp = null;
                        var secondsElapsed = 0.0;
                        function frame(timestamp) {
                                if (previousFrameTimestamp === null) previousFrameTimestamp = timestamp;
                                const deltaTime = (timestamp - previousFrameTimestamp) * 0.001;
                                secondsElapsed += deltaTime;

                                // Run behaviors
                                for (let i = 0; i < demoData.sprites.length; i++) {
                                        const data = demoData.spritesData.get(demoData.sprites[i].id);
                                        if (data === undefined) continue;
                                        behaviors[data.tag](
                                                demoData.sprites[i], data, deltaTime
                                        );
                                }
                                
                                // Run next action in the sequence
                                if (!demoData.sequence.isEmpty() && 
                                secondsElapsed - demoData.currentSequenceMemberStart >= demoData.nextSequenceMemberDelay) 
                                {
                                        demoData.sequence.dequeue()();
                                        demoData.currentSequenceMemberStart = secondsElapsed;
                                }
                                demoData.containerElem.style.backgroundPosition = Math.floor(secondsElapsed*40)+"px 100%";
                                
                                previousFrameTimestamp = timestamp;
                                window.requestAnimationFrame(frame);
                        }
                        
                        var behaviors = {
                                'heart': (sprite, data, deltaTime) => {
                                        data.timeAlive += deltaTime;
                                        if (sprite.domElement === null) return;
                                        let xMod = 300;
                                        if (sprite.transform.position.x >= 1024 - sprite.getWidth()) 
                                                data.directionX = -1;
                                        else if (sprite.transform.position.x <= 0) 
                                                data.directionX = 1;
                                        xMod *= data.directionX;
                                        const newPos = new Vector2(
                                                sprite.transform.position.x + xMod*0.02,
                                                100 + Math.sin(data.timeAlive*3)*60
                                        );
                                        const move = Vector2.sub(newPos, sprite.transform.position);
                                        
                                        demoData.collisionGrid.update(
                                                sprite, 
                                                sprite.getBoundingBox(), 
                                                move
                                        );
                                        
                                        const collisions = demoData.collisionGrid.getCollisions(
                                                sprite, sprite.getBoundingBox());
                                        for (let i = 0; i < collisions.length; i++) {
                                                const tag = demoData.spritesData.get(collisions[i].id).tag;
                                                if (tag === "heart" && 
                                                collisions[i].transform.position.x > sprite.transform.position.x) {
                                                        data.directionX = -1
                                                } else if (tag === "heart") {
                                                        data.directionX = 1;
                                                } else if (tag === "cloudpuff") {
                                                        demoData.spritesData.get(collisions[i].id).
                                                                animation.start();
                                                        demoData.collisionGrid.remove(
                                                                collisions[i], collisions[i].getBoundingBox());
                                                }
                                        }
                                                
                                        sprite.transform.position = newPos;
                                        sprite.transform.scale.x = 1.0 + Math.sin(data.timeAlive)*0.5;
                                        sprite.transform.scale.y = 1.0 + Math.sin(data.timeAlive)*0.5;
                                        sprite.update();
                                },
                                'cloudpuff': (sprite, data, deltaTime) => {
                                        data.timeAlive += deltaTime;
                                        
                                        const move = Vector2.mul(Vector2.Right, -120 * deltaTime);
                                        if (!data.animation.running) {
                                                if (sprite.domElement.style.display !== "none")
                                                        demoData.collisionGrid.update(
                                                                sprite, sprite.getBoundingBox(), move
                                                                );
                                        } else { data.animation.update(deltaTime) };
                                        sprite.transform.position.addVector(move);
                                        sprite.update();
                                        if (sprite.transform.position.x < sprite.getWidth() * -1) {
                                                sprite.transform.position.x += 1024 + sprite.getWidth();
                                                data.animation.currentIndex = 0;
                                                data.animation.running = false;
                                                sprite.sheetPosition.x = 0;
                                                sprite.domElement.style.display = "block";
                                        }
                                }
                        };
                        
                </script>
        </head>
        <body style="margin:0;padding:0;background-color:#000000;color:#F3E5AB;font-family:monospace;">
                <div id="test-container" class="vb__window" style="width:1024px; height:768px; margin: 0 auto; position: relative; overflow: hidden; background-color:darkslateblue;">
                        <h1 style="display:block;position:absolute">Vanilla Beans</h1>
                </div>
        </body>
</html>