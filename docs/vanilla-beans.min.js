class FixedResolutionGrid{constructor(cellSize,gridWidth,gridHeight,pointCollisionTest,elementsCollisionTest){this.cellSize=cellSize,this.width=gridWidth,this.height=gridHeight,this.pointCollisionTest=pointCollisionTest,this.elementsCollisionTest=elementsCollisionTest,this.cells=new Array(gridHeight).fill(new Array(gridWidth).fill([],0,gridWidth),0,gridWidth)}_getCoordsAtPoint(x,y){return[Math.floor(x/this.cellSize),Math.floor(y/this.cellSize)]}_getCell(boundingBox){var[boundingBox,y]=this._getCoordsAtPoint(boundingBox.x1+.5*(boundingBox.x2-boundingBox.x1),boundingBox.y1+.5*(boundingBox.y2-boundingBox.y1));return this.cells[y][boundingBox]}insert(value,boundingBox){this._getCell(boundingBox).push(value)}remove(value,boundingBox){var cell=this._getCell(boundingBox);for(let i=0;i<cell.length;i++)if(value===cell[i]){cell.splice(i,1);break}}update(value,boundingBox,movement){if(0!==movement.x||0!==movement.y){var[prevX,prevY]=this._getCoordsAtPoint(boundingBox.x1+.5*(boundingBox.x2-boundingBox.x1),boundingBox.y1+.5*(boundingBox.y2-boundingBox.y1)),[movement,boundingBox]=this._getCoordsAtPoint(movement.x+boundingBox.x1+.5*(boundingBox.x2-boundingBox.x1),movement.y+boundingBox.y1+.5*(boundingBox.y2-boundingBox.y1));if(prevX!==movement||prevY!==boundingBox){var prevCell=this.cells[prevY][prevX];for(let i=0;i<prevCell.length;i++)value===prevCell[i]&&prevCell.splice(i,1);0<=boundingBox&&boundingBox<this.height&&0<=movement&&movement<this.width&&this.cells[boundingBox][movement].push(value)}}}getAtPoint(point){var[x,y]=this._getCoordsAtPoint(point.x,point.y),cell=(console.log(x+"|"+y+" CHECKING"),this.cells[y][x]),hits=[];for(let i=0;i<cell.length;i++)this.pointCollisionTest(cell[i],point)&&hits.push(cell[i]);return hits}getCollisions(value,boundingBox){var cellX1=Math.floor(boundingBox.x1/this.cellSize),cellY1=Math.floor(boundingBox.y1/this.cellSize),cellX2=Math.floor(boundingBox.x2/this.cellSize),cellsY=[cellY1,Math.floor(boundingBox.y2/this.cellSize)],cellsX=[cellX1,cellX2],hits=[];for(let yi=0;yi<cellsY.length;yi++){var y=cellsY[yi];for(let xi=0;xi<cellsX.length;xi++){var x=cellsX[xi],cell=this.cells[y][x];for(let i=0;i<cell.length;i++)cell[i]!==value&&this.elementsCollisionTest(value,cell[i])&&hits.push(cell[i])}}return hits}}class HashTable{constructor(){this.table=new Array(127),this.size=0}*[Symbol.iterator](){for(let i=0;i<this.size;i++){if(this.table[i].length)continue;for(let y=0;y<this.table[i].length;y++)yield this.table[i][y][1]}}_hash(key){let hash=0;for(let i=0;i<key.length;i++)hash+=key.charCodeAt(i);return hash%this.table.length}set(key,value){var index=this._hash(key);if(this.table[index]){for(let i=0;i<this.table[index].length;i++)if(this.table[index][i]===key)return void(this.table[index][i][1]=value)}else this.table[index]=[];this.table[index].push([key,value]),this.size++}get(key){var index=this._hash(key);if(this.table[index])for(let i=0;i<this.table[index].length;i++)if(this.table[index][i][0]===key)return this.table[index][i][1]}remove(key){var index=this._hash(key);if(this.table[index]&&this.table[index].length)for(let i=0;i<this.table[index].length;i++)if(this.table[index][i][0]===key)return this.table[index].splice(i,1),this.size--,!0;return!1}toString(){let table="";return this.table.forEach((values,index)=>{values=values.map((key,value)=>`[ ${key}: ${value} ]`);table+=index+" => "+values+"\n"}),table}}class Queue{constructor(){this.items={},this.frontIndex=0,this.backIndex=0}enqueue(item){return this.items[this.backIndex]=item,this.backIndex++,item+" inserted"}dequeue(){var item=this.items[this.frontIndex];return delete this.items[this.frontIndex],this.frontIndex++,item}peek(){return this.items[this.frontIndex]}isEmpty(){return 0==Object.keys(this.items).length}get printQueue(){return this.items}}class Sprite{constructor(id,spriteDefinition,transform){this.id=id,this.definition=spriteDefinition,this.transform=transform,this.container=null,(this.domElement=null)===Sprite.idMap&&(Sprite.idMap=new HashTable),Sprite.idMap.set(id,this)}getBoundingBox(){return{x1:this.transform.position.x,y1:this.transform.position.y,x2:this.transform.position.x+this.definition.width*this.transform.scale.x,y2:this.transform.position.y+this.definition.height*this.transform.scale.y}}toHtml(){return`
                <div id="sprite_${this.definition.id}_${this.id}" class="vb__sprite"
                style="background-image:url(${this.definition.imagePath});width:${Math.round(this.definition.width*this.transform.scale.x)}px;height:${Math.round(this.definition.height*this.transform.scale.y)}px;
                transform: translate(${this.transform.position.x}px, ${this.transform.position.y}px)"
                ></div>
                `}update(){var elem;null!==this.domElement&&(this.domElement=document.getElementById("sprite_"+this.definition.id+"_"+this.id),(elem=this.domElement).style.width=Math.round(this.definition.width*this.transform.scale.x)+"px",elem.style.height=Math.round(this.definition.height*this.transform.scale.y)+"px",elem.style.transform="translate("+this.transform.position.x+"px, "+this.transform.position.y+"px)")}}Sprite.addToContainer=function(containerElem,sprite){null!==sprite.container&&Sprite.removeFromContainer(sprite),containerElem.innerHTML+=sprite.toHtml();var cs=(sprite.container=containerElem).querySelectorAll(":scope > .vb__sprite");for(let i=0;i<cs.length;i++){var id=cs[i].id.split("_")[2];Sprite.idMap.get(id).domElement=cs[i]}},Sprite.removeFromContainer=function(sprite){var spriteElem;null!==sprite.container&&null!==(spriteElem=sprite.domElement)&&(spriteElem.remove(),sprite.domElement=null)},Sprite.idMap=null;class SpriteDefinition{constructor(id,imagePath,widthPx,heightPx){this.id=id,this.imagePath=imagePath,this.width=widthPx,this.height=heightPx,SpriteDefinition.table.set(id,this)}}SpriteDefinition.table=new HashTable;class FullBinaryTree{}class FBTNode{constructor(data){this.data=data,this.left=null,this.right=null}}class MaxHeap{constructor(data=[]){this.data=data,this.comp={lt:(a,b)=>a<b,gt:(a,b)=>b<a}}add(element){element=this.data.push(element);this.heapify(this.data,element,0)}heapify(data,length,index){let largest=index;var left=2*index+1,right=2*index+2;left<length&&this.comp.gt(data[left],data[index])&&(largest=left),(largest=right<length&&this.comp.gt(data[right]>data[index])?right:largest)!=index&&([data[index],data[largest]]=[data[largest],data[index]],heapify(data,length,largest))}}class Tree{constructor(root=null,comparer){this.root=root,this.comparer=comparer}}class TNode{constructor(data,parent=0){this.data=data,this.children=[]}addChild(node){return(node.parent=this).children.push(node),this.children.length}}class Collision{}Collision.simpleBoxesOverlap=(b1,b2)=>b1.x1<b2.x2&&b2.x1<b1.x2&&b1.y1<b2.y2&&b2.y1<b1.y2;class Events{constructor(){this.eventListenerMap={},Events.instance=this}createEvent(eventName){this.eventListenerMap[eventName]=[]}registerEventListener(object,eventName){void 0===this.eventListenerMap[eventName]?console.warn("EVENT NOT REGISTERED: "+eventName):this.eventListenerMap[eventName].push(object)}dispatch(eventName,data){if(void 0===this.eventListenerMap[eventName])console.warn("EVENT NOT REGISTERED: "+eventName);else{var handlerName=this.getEventHandlerName(eventName),listeners=this.eventListenerMap[eventName];for(let i=0;i<listeners.length;i++)void 0===listeners[i][handlerName]?console.warn("EVENT LISTENER NOT IMPLEMENTED "+listeners[i]+" FOR "+handlerName):listeners[i][handlerName](data)}}getEventHandlerName(eventName){return"on"+eventName.charAt(0).toUpperCase()+eventName.slice(1)}}